/** \file sonyremote.c
 *
 * \author Copyright 2021 Rafa≈Ç Hirsz <rafal@hirsz.co>
 * \author Copyright 2021 Marcus Meissner <marcus@jet.franken.de>
 *
 * \par
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * \par
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * \par
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301  USA
 *
 * \section intro Introduction to camera drivers (camlibs)
 *
 * Every camlib must implement the following three function groups:
 *
 *   - Camera object member functions
 *   - CameraFilesystem object member functions
 *   - camlib API functions
 *
 * We implement the camlib API functions last in this file because
 * camera_init() must reference all the object member functions and by
 * making camera_init() the last function in this file, we can avoid
 * the need for forward declarations of the object member functions.
 *
 * \section linknote Note about "static" functions and exporting symbols
 *
 * The build system uses libtool to explicitly specify the list of
 * exported symbols. Only the three functions of the camlib API
 * (camera_init(), camera_id(), and camera_abilities()) are exported.
 *
 * Therefore it doesn't matter whether you declare your other
 * functions static or not - regardless of whether they are object
 * member functions or internal camlib functions.
 *
 * We do not define the object member functions as static in this
 * template in order to have autogenerated documentation about them.
 *
 */
#include "config.h"

#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#include "jsmn.h"

#include <gphoto2/gphoto2-library.h>
#include <gphoto2/gphoto2-result.h>

#ifdef ENABLE_NLS
#include <libintl.h>
#undef _
/**
 * This define is the string translation macro used in
 * libgphoto2. It will resolve to a dcgettext() function call and
 * does both the translation itself and also marks up the string
 * for the collector (xgettext).
 */
#define _(String) dgettext(GETTEXT_PACKAGE, String)
#ifdef gettext_noop
/**
 * This is the noop translation macro, which does not translate the
 * string, but marks it up for the extraction of translatable strings.
 */
#define N_(String) gettext_noop(String)
#else
#define N_(String) (String)
#endif
#else
#define _(String) (String)
#define N_(String) (String)
#endif

/**********************************************************************/
/**
 * @name Structures and utility functions
 * @{
 */
/**********************************************************************/

typedef struct StringVector {
	char **items;
	size_t count;
} StringVector;

static StringVector string_vector_new(size_t count)
{
	StringVector vector;
	vector.items = calloc(count, sizeof(char *));
	vector.count = count;
	return vector;
}

static char *string_vector_get(StringVector *vector, size_t index)
{
	return vector->items[index];
}

static int string_vector_set(StringVector *vector, size_t index, char *data,
			     int length)
{
	if (index >= vector->count) {
		/* Out of bounds. */
		return 0;
	}

	if (vector->items[index] != NULL) {
		free(vector->items[index]);
	}
	/** Handle null-terminated strings. */
	size_t actualLength = (length < 0) ? strlen(data) : (size_t)length;

	char *string = malloc(actualLength + 1);
	memcpy(string, data, actualLength);
	string[actualLength + 1] = 0;
	vector->items[index] = string;

	return 1;
}

static int string_vector_add(StringVector *vector, char *data, int length)
{
	vector->count++;
	vector->items = realloc(vector->items, vector->count * sizeof(char *));
	return string_vector_set(vector, vector->count, data, length);
}

static void string_vector_free(StringVector *vector)
{
	for (size_t i = 0; i < vector->count; ++i) {
		free(vector->items[i]);
	}
	free(vector->items);
}

struct Response {
	char *data;
	size_t size;
};

static void response_init(struct Response *response)
{
	response->data = malloc(0);
	response->size = 0;
}

static void response_free(struct Response *response)
{
	free(response->data);
}

static size_t response_write(char *contents, size_t size, size_t n,
			     void *output)
{
	size_t realSize = size * n;
	struct Response *response = output;
	size_t oldSize = response->size;

	/* One extra byte for null terminator. */
	char *ptr = realloc(response->data, response->size + realSize + 1);
	if (!ptr) {
		GP_LOG_E("Out of memory");
		return 0;
	}

	response->data = ptr;
	response->size += realSize;
	response->data[response->size] = 0;

	GP_LOG_DATA(contents, realSize, "Sony Remote API response");

	memcpy(response->data + oldSize, contents, realSize);
	return realSize;
}

struct JsonResponse {
	struct Response response;
	jsmntok_t *tokens;
	size_t numTokens;
};

static void json_response_init(struct JsonResponse *response, size_t numTokens)
{
	response_init(&response->response);
	response->tokens = calloc(numTokens, sizeof(jsmntok_t));
	response->numTokens = numTokens;
}

static void json_response_free(struct JsonResponse *response)
{
	free(response->tokens);
	response_free(&response->response);
}

/**
 * Sends an RPC request to the Remote Camera API.
 *
 * @param camera The camera.
 * @param service Service name, e.g. "camera" or "avContent".
 * @param method Method name to call, e.g. "getAvailableApiList".
 * @param params String representing a JSON array with params. Can be NULL.
 * @param output Pointer to where the JSON output should be written.
 * @return Error code.
 */
static int send_request(Camera *camera, const char *service, const char *method,
			char *params, struct Response *output)
{
	int err = GP_OK;

	/* Get the IP and format into an URL. */
	GPPortInfo portInfo;
	err = gp_port_get_info(camera->port, &portInfo);
	if (err != GP_OK) {
		GP_LOG_E("Failed to get camera port");
		return err;
	}
	char *portPath;
	gp_port_info_get_path(portInfo, &portPath);

	char url[80];
	/** The 3 is for skipping "ip:" from the beginning. */
	snprintf(url, 80, "http://%s:8080/sony/%s", portPath + 3, service);

	/** Format JSON data to send. */
	if (params == NULL) {
		params = "[]";
	}

	GP_LOG_D("Calling method %s on %s (params: %s)", method, url, params);
	char json[2048];
	snprintf(json, 2048,
		 "{"
		 "\"id\":1,"
		 "\"version\":\"1.0\","
		 "\"method\":\"%s\","
		 "\"params\":%s"
		 "}",
		 method, params);

	/** Initialize cURL. */
	CURL *curl = curl_easy_init();
	if (!curl) {
		GP_LOG_E("Could not initialize cURL");
		return GP_ERROR_IO_INIT;
	}

	/** Configure the request. */
	struct curl_slist *headers = NULL;
	headers = curl_slist_append(headers, "Content-Type: application/json");

	curl_easy_setopt(curl, CURLOPT_URL, url);
	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, response_write);
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, output);

	/** Send the request. */
	CURLcode result = curl_easy_perform(curl);
	err = GP_OK;
	if (result != CURLE_OK) {
		GP_LOG_E("cURL request failed: %s", curl_easy_strerror(result));
		err = GP_ERROR_IO_READ;
	}

	curl_slist_free_all(headers);
	curl_easy_cleanup(curl);
	return err;
}

static int send_blind_request(Camera *camera, const char *service,
			      const char *method, char *params)
{
	struct Response response;
	response_init(&response);
	int err = send_request(camera, service, method, params, &response);
	response_free(&response);
	return err;
}

static int send_json_request(Camera *camera, const char *service,
			     const char *method, char *params,
			     struct JsonResponse *output)
{
	int err = send_request(camera, service, method, params,
			       &output->response);
	if (err != GP_OK) {
		return err;
	}

	jsmn_parser parser;
	jsmn_init(&parser);
	err = jsmn_parse(&parser, output->response.data, output->response.size,
			 output->tokens, output->numTokens);
	if (err < 0) {
		GP_LOG_E("Failed to parse JSON, error code %d", err);
		return GP_ERROR_IO;
	}

	return GP_OK;
}

/*@}*/

/**********************************************************************/
/**
 * @name Interactions with the Camera Remote API
 *
 * @{
 */
/**********************************************************************/

struct _CameraPrivateLibrary {
	/**
	 * If true, the camera needs startRecMode/stopRecMode calls to function
	 * properly.
	 */
	int needsRecMode;
};

static void check_needs_rec_mode(Camera *camera)
{
	camera->pl->needsRecMode = 0;

	struct JsonResponse json;
	json_response_init(&json, 128);
	int err = send_json_request(camera, "camera", "getAvailableApiList",
				    NULL, &json);
	if (err != GP_OK) {
		goto cleanup;
	}

	/* Find the results array. */
	size_t arrayStart = SIZE_MAX;
	size_t arrayEnd = 0;
	for (int i = 0; i < 128; ++i) {
		if (json.tokens[i].type == JSMN_STRING &&
		    json.tokens[i].size == 1 &&
		    memcmp(json.response.data + json.tokens[i].start, "result",
			   6) == 0) {
			/* Found the "result" or "results" key. The next token
			 * will be an array of results. Since there is one
			 * result, the token after that is the actual array of
			 * method names, Method names follow afterwards. */
			arrayStart = i + 3;
			arrayEnd = arrayStart + json.tokens[i + 2].size;
			break;
		}
	}
	if (arrayStart == SIZE_MAX) {
		GP_LOG_E("Could not find the result array");
		goto cleanup;
	}

	/* Check if the array contains the "startRecMode" method. */
	for (size_t i = arrayStart; i < arrayEnd; ++i) {
		jsmntok_t *token = &json.tokens[i];
		size_t nameLength = token->end - token->start;
		if (nameLength != strlen("startRecMode")) {
			continue;
		}
		if (memcmp(json.response.data + token->start, "startRecMode",
			   nameLength) == 0) {
			GP_LOG_D("Camera supports startRecMode");
			camera->pl->needsRecMode = 1;
			break;
		}
	}

cleanup:
	json_response_free(&json);
}

/*@}*/

/**********************************************************************/
/**
 * @name Camera object member functions
 *
 * The prototypes for these functions are defined in gphoto2-camera.h
 *
 * @{
 */
/**********************************************************************/

/**
 * Finish up the camera communication and free
 * private data. You do not need to close the port.
 *
 * This function is a method of the Camera object.
 */
int camera_exit(Camera *camera, GPContext *context);
int camera_exit(Camera *camera, GPContext *context)
{
	/* Stop rec mode on cameras that also start it. */
	if (camera->pl->needsRecMode) {
		send_blind_request(camera, "camera", "stopRecMode", NULL);
	}

	return GP_OK;
}

/**
 * Get the full configuration tree of the camera.
 *
 * This function is a method of the Camera object.
 */
int camera_config_get(Camera *camera, CameraWidget **window,
		      GPContext *context);
int camera_config_get(Camera *camera, CameraWidget **window, GPContext *context)
{
	gp_widget_new(GP_WIDGET_WINDOW, "Camera Configuration", window);

	/* Append your sections and widgets here. */

	return GP_OK;
}

/**
 * Set parts of the configuration tree. Note that you get
 * back the whole tree, but should only set the modified
 * values.
 *
 * This function is a method of the Camera object.
 */
int camera_config_set(Camera *camera, CameraWidget *window, GPContext *context);
int camera_config_set(Camera *camera, CameraWidget *window, GPContext *context)
{
	/*
	 * Check if the widgets' values have changed. If yes, tell the camera.
	 */

	return GP_OK;
}

/**
 * Capture a preview and return the data in the given file (again,
 * use gp_file_set_data_and_size, gp_file_set_mime_type, etc.).
 * libgphoto2 assumes that previews are NOT stored on the camera's
 * disk. If your camera does, please delete it from the camera.
 *
 * This function is a method of the Camera object.
 */
int camera_capture_preview(Camera *camera, CameraFile *file,
			   GPContext *context);
int camera_capture_preview(Camera *camera, CameraFile *file, GPContext *context)
{
	return GP_OK;
}

/**
 * Capture an image and tell libgphoto2 where to find it by filling
 * out the path.
 *
 * This function is a method of the Camera object.
 */
int camera_capture(Camera *camera, CameraCaptureType type, CameraFilePath *path,
		   GPContext *context);
int camera_capture(Camera *camera, CameraCaptureType type, CameraFilePath *path,
		   GPContext *context)
{
	return GP_OK;
}

/**
 * Fill out the summary with textual information about the current
 * state of the camera (like pictures taken, etc.).
 *
 * This function is a method of the Camera object.
 */
int camera_summary(Camera *camera, CameraText *summary, GPContext *context);
int camera_summary(Camera *camera, CameraText *summary, GPContext *context)
{
	return GP_OK;
}

/**
 * Return the camera drivers manual.
 * If you would like to tell the user some information about how
 * to use the camera or the driver, this is the place to do.
 *
 * This function is a method of the Camera object.
 */
int camera_manual(Camera *camera, CameraText *manual, GPContext *context);
int camera_manual(Camera *camera, CameraText *manual, GPContext *context)
{
	return GP_OK;
}

/**
 * Return "About" content as textual description.
 * Will be translated.
 *
 * This function is a method of the Camera object.
 */
int camera_about(Camera *camera, CameraText *about, GPContext *context);
int camera_about(Camera *camera, CameraText *about, GPContext *context)
{
	strcpy(about->text, _("Library Name\n"
			      "YOUR NAME <email@somewhere.com>\n"
			      "Quick description of the library.\n"
			      "No more than 5 lines if possible."));

	return GP_OK;
}

/*@}*/

/**********************************************************************/
/**
 * @name CameraFilesystem member functions
 *
 * @{
 */
/**********************************************************************/

/**
 * Get information on all available storages in the camera.
 *
 * This function is a CameraFilesystem method.
 */
int storage_info_func(CameraFilesystem *fs,
		      CameraStorageInformation **storageinformations,
		      int *nrofstorageinformations, void *data,
		      GPContext *context);
int storage_info_func(CameraFilesystem *fs,
		      CameraStorageInformation **storageinformations,
		      int *nrofstorageinformations, void *data,
		      GPContext *context)
{
	/*Camera *camera = data;*/

	/* List your storages here */

	return GP_ERROR_NOT_SUPPORTED;
}

/*@}*/

/**********************************************************************/
/**
 * @name camlib API functions
 *
 * @{
 */
/**********************************************************************/

/**
 * Set library ID string.
 *
 * Probably redundant and to be removed shortly, being replaced
 * by the libtool module name defined in the build system.
 *
 * This is a camlib API function.
 */
int camera_id(CameraText *id)
{
	strcpy(id->text, "Sony Remote");

	return GP_OK;
}

/**
 * Fill list with abilities of the cameras supported by this camlib.
 *
 * For each camera, fill a CameraAbilities structure with data about
 * that camera and append it to the list.
 *
 * The job of this function is  basically to extract data from a
 * camlib specific database and insert it into the libgphoto2 camera
 * database. Due to redundant data and other issues, we may decide to
 * revise that database mechanism and replace it by something more
 * flexible and efficient.
 *
 * This is a camlib API function.
 */
int camera_abilities(CameraAbilitiesList *list)
{
	CameraAbilities a;

	memset(&a, 0, sizeof(a));
	strcpy(a.model, "Sony:Alpha (Remote)");
	a.status = GP_DRIVER_STATUS_EXPERIMENTAL;
	a.port = GP_PORT_IP;
	a.operations = GP_OPERATION_NONE;
	a.file_operations = GP_FILE_OPERATION_NONE;
	a.folder_operations = GP_FOLDER_OPERATION_NONE;

	gp_abilities_list_append(list, a);

	return GP_OK;
}

/**
 * All filesystem accessor functions.
 *
 * This should contain all filesystem accessor functions
 * available in the camera library. Non-present fields
 * are NULL.
 *
 */
CameraFilesystemFuncs fsfuncs = {
	//	.file_list_func = file_list_func,
	//	.folder_list_func = folder_list_func,
	//	.get_info_func = get_info_func,
	//	.set_info_func = set_info_func,
	//	.get_file_func = get_file_func,
	//	.del_file_func = delete_file_func,
	//	.put_file_func = put_file_func,
	//	.delete_all_func = delete_all_func,
	.storage_info_func = storage_info_func
};

/**
 * Initialize a Camera object.
 *
 * Sets up all the proper object function pointers, initialize camlib
 * internal data structures, and probably establish a connection to
 * the camera.
 *
 * This is a camlib API function.
 */
int camera_init(Camera *camera, GPContext *context)
{
	/* First, set up all the function pointers */
	camera->functions->exit = camera_exit;
	camera->functions->get_config = camera_config_get;
	camera->functions->set_config = camera_config_set;
	camera->functions->capture = camera_capture;
	camera->functions->capture_preview = camera_capture_preview;
	camera->functions->summary = camera_summary;
	camera->functions->manual = camera_manual;
	camera->functions->about = camera_about;

	/* Initialize the private library. */
	camera->pl = malloc(sizeof(CameraPrivateLibrary));

	/* Now, tell the filesystem where to get lists, files and info */
	gp_filesystem_set_funcs(camera->fs, &fsfuncs, camera);

	/* We don't use SSL and I think gphoto2 initializes sockets on
	 * Windows. */
	curl_global_init(CURL_GLOBAL_NOTHING);

	/* Start rec mode on cameras that need it. */
	check_needs_rec_mode(camera);
	if (camera->pl->needsRecMode) {
		send_blind_request(camera, "camera", "startRecMode", NULL);
	}

	return GP_OK;
}

/*@}*/

/*********************************************************************
 * End of camlib template.
 *********************************************************************/

/*
 * Local Variables:
 * c-file-style:"linux"
 * indent-tabs-mode:t
 * End:
 */
